package controllers

import org.scalatestplus.play.*
import org.scalatestplus.play.guice.*
import play.api.mvc.*
import play.api.test.*
import play.api.test.Helpers.*
import models.Product

import scala.collection.mutable.ListBuffer
import scala.concurrent.Future

class ProductControllerSpec extends PlaySpec with GuiceOneAppPerTest with Injecting {
  """
    Test are generated by ChatGPT
  """

  "ProductController" should {

    "return all products (GET /products)" in {
      val controller = inject[ProductController]
      val result: Future[Result] = controller.getAllProducts().apply(FakeRequest(GET, "/products"))

      status(result) mustBe OK
      contentType(result) mustBe Some("text/plain")
      contentAsString(result) must include("Spoon")
      contentAsString(result) must include("Fork")
    }

    "return a product by ID (GET /products/:id)" in {
      val controller = inject[ProductController]
      val result: Future[Result] = controller.getProductById(1).apply(FakeRequest(GET, "/products/1"))

      status(result) mustBe OK
      contentAsString(result) must include("Spoon")
    }

    "return 404 when product not found (GET /products/:id)" in {
      val controller = inject[ProductController]
      val result: Future[Result] = controller.getProductById(999).apply(FakeRequest(GET, "/products/999"))

      status(result) mustBe NOT_FOUND
    }

    "add a new product (POST /products/add)" in {
      val controller = inject[ProductController]
      val result: Future[Result] = controller.addProduct(3, "Knife", 6.99).apply(FakeRequest(POST, "/products/add"))

      status(result) mustBe CREATED
      contentAsString(result) must include("Product Knife added")

      // Sprawdzamy, czy produkt rzeczywiście został dodany
      val getResult = controller.getAllProducts().apply(FakeRequest(GET, "/products"))
      contentAsString(getResult) must include("Knife")
    }

    "update an existing product (PUT /products/update)" in {
      val controller = inject[ProductController]

      val updateResult: Future[Result] = controller.updateProduct(1, "New Spoon", 7.99)
        .apply(FakeRequest(PUT, "/products/update"))

      status(updateResult) mustBe OK
      contentAsString(updateResult) must include("Product 1 updated")

      // Sprawdzamy, czy produkt został zaktualizowany
      val getResult = controller.getProductById(1).apply(FakeRequest(GET, "/products/1"))
      contentAsString(getResult) must include("New Spoon")
    }

    "return 404 when updating non-existing product (PUT /products/update)" in {
      val controller = inject[ProductController]

      val updateResult: Future[Result] = controller.updateProduct(999, "Ghost", 9.99)
        .apply(FakeRequest(PUT, "/products/update"))

      status(updateResult) mustBe NOT_FOUND
    }

    "delete a product (DELETE /products/:id)" in {
      val controller = inject[ProductController]

      val deleteResult: Future[Result] = controller.deleteProduct(1).apply(FakeRequest(DELETE, "/products/1"))

      status(deleteResult) mustBe OK
      contentAsString(deleteResult) must include("Product 1 deleted")

      // Sprawdzamy, czy produkt został usunięty
      val getResult = controller.getProductById(1).apply(FakeRequest(GET, "/products/1"))
      status(getResult) mustBe NOT_FOUND
    }

    "return 404 when deleting a non-existing product (DELETE /products/:id)" in {
      val controller = inject[ProductController]

      val deleteResult: Future[Result] = controller.deleteProduct(999).apply(FakeRequest(DELETE, "/products/999"))

      status(deleteResult) mustBe NOT_FOUND
    }
  }
}
